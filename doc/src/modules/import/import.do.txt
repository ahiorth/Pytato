# Here goes the main text.
# The text may be split into several files and included here
# via preprocess: # #include "file1.do.txt" etc

======= One reason Python is so popular: The import statement =======
It is always hard decide which coding language to learn, it usually depends on what you want to do. If you want to do very fast numerical calculations Fortan or C used to be the most popular languages, and for web or application programming Java. However, in recent years Python has become more and more popular, one of the reasons is its large amount of libraries and communities. If you have an idea of what you want to do, you can almost be certain that there exist a Python library written for that purpose. In the next chapters we will cover some advanced operations in Python and use them to motivate to learn more about the basic operations.

!bnotice Which library to use?
This is not easy to answer, but here we will introduce you to the most popular libraries. We will suggest to stick to as few libraries as possible and try to achieve what you want with these. 
!enotice


!split
======= Vanilla Python =======
idx{vanilla Python}
Before proceeding with the libraries, it is worth mentioning that if you write Python code without importing libraries, it is usually referred to as *vanilla Python*, i.e. Python without flavors. You can achieve a lot using vanilla Python, but you will have to write much more code compared to what you would do if you imported a library. This also means that you can import a library and *never* write vanilla Python to achieve what you want. In many ways you can think of a library as an interface to Python, as illustrated in figure ref{fig:im:fl}. Libraries also have different levels of complexity, such as the Pandas library, which is almost like its own programming language. Libraries like Pandas and Numpy work on groups of data, e.g. in vanilla Python `x+y` would be to take a single number and add to another (e.g. `1+3=4`), whereas in Pandas and Numpy we would add one array of numbers to another (e.g. `[1,2,3]+[5,6,7]=[6,8,10]`). 

FIGURE: [fig-import/flavors.png, width=400 frac=1.0] Different levels of interacting with Python. label{fig:im:fl}

!bnotice Be specific when you search for help!
Due to the large amount of libraries in Python, it is possible to achieve similar things in Python in many different ways. This means that if you are working with e.g. the Pandas library and need help, you should search ''How can I achieve this in *Pandas*?'', instead of ''How can I achieve this in Python?''. The reason is that there is a high chance that there already is a solution to your problem within the library you use, this solution will be much easier than relying on another library to achieve what you want.
!enotice

!split
======= Vanilla Python: for loops =======
idx{for loop}
idx{lists}
Loops are so fundamental to any programming language, that I have chosen to explain this before we move on to libraries. In order to have a meaningful discussion about loops, we need to have something to loop over, and then we need to introduce another basic Python data structure: lists.
We will return to lists later, but for now you the only thing you need to know is that they contain different types of data and are defined using a square bracket
!bc pypro
list1=[10,20,30] # numbers, integers
list2=[0.1,0.2,0.3] # numbers, floats
list3=['dog','cat','mouse'] #strings
len(list1) # 3, gives the length of the list
!ec

!bnotice Python indexing starts at 0
The first element is always given the index 0, the second 1, and so on. Thus the last index is always one less than the length of the list. If we assume the list has length `N`, we access the first element as `list[0]` and the last as `list[N-1]`. In Python, we can also access the last element by dropping `N`, i.e. `list[-1]`. 
!enotice

To print out all elements in lists we can use a for loop. The syntax for a for loop in Python is as follows
!bc pycod
N=len(list1) #N = 3, length of list
for i in range(N):
    print(list1[i]) # prints 10, 20, 30
!ec
There are a few things to note idx{generator}
* `range(N)` is a Python function called a *generator*, the effect is that it generates a list starting from 0, until N-1, in this case `[0,1,2]`
* `for i in range(N):` have the effect that `i` will be assigned the first value in the list generated by `range(N)`, 0,  then the next value, until it has taken all the values (0,1,2).
* Indentation: Everything that is part of the for loop has to be indented with the same number of spaces. Normally, I just use the tabular on the keyboard.
* The variable name `i` is *arbitrary*, we can choose whatever name we want.

===== A more pythonic for loop =====
The for loop above is not so much used in Python, because it is not so elegant. Why generate a list by the command `range(N)`, why not loop directly over the element in `list1`? This can be done by the following syntax 
!bc pycod
for elem in list1:
    print(elem) # prints 10, 20, 30
!ec
Note that this code is much simpler than by accessing elements in the list by indexing. As before the variable name `elem` is arbitrary.

===== Zip: how to loop over more than one list? =====
idx{zip}
Ok, the code above is more elegant, but how can we iterate over more than one list? Let say that we want to print out the sum of each element in `list1` and `list2`, if we have the index, we can do `print(list1[0]+list2[0])`. However, in Python it is more elegant to use `zip()`
!bc pycod
for l1,l2 in zip(list1,list2):
    print(l1+l2) # prints 10.1, 20.2, 30.3
!ec
You can use `zip()` with more than two lists.

===== Append: create a new list =====
idx{append}
Usually in a for loop we do an operation and we want to store the result of those operation. The way to achieve this is to
o create and empty list
o append stuff to the empty list, e.g.
!bc pycod
new_list=[] # empty list
for l1,l2 in zip(list1,list2):
    new_list.append(l1+l2)
print(new_list) # [10.1, 20.2, 30.3]
!ec
!split
======= Matplotlib: Basic plotting in Python =======
idx{matplotlib}
FIGURE: [fig-import/my_plot.png, width=400 frac=1.0] An example of a plot in Python. label{fig:im:pl}

The code for creating the plot in figure ref{fig:im:pl} is
!bc pycod
import matplotlib.pyplot as plt
x=[1,2,3,4]
y=[2,4,9,16] # y=x*x
plt.plot(x,y,label='y=$x^2$')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Title of my plot')
plt.legend() # try to remove and see what happens
plt.grid()   # try to remove and see what happens
!ec
Let us go through each line
o `import matplotlib.pyplot as plt`: this line tells Python to import the "matplotlib.pyplot":"https://matplotlib.org/3.5.3/api/_as_gen/matplotlib.pyplot.html" library, which we need to make plots. We use the `as` statement to indicate that we will name the `matplotlib.pyplot` library as `plt`. Thus we do not need to write `matplotlib.pyplot` every time we want to use a function in this library. We access functions in the library by simply placing a `.` after `plt`.
o Next, we define two lists `x` and `y`, these lists have to be of equal length.
o The `plt.plot` commands plots `y` vs `x`, the label command describes the legend, by using a dollar sign `$` we can use \LaTeX commands to display math.
o `plt.xlabel('x')` and `plt.ylabel('y')` displays text for the $x-$ and $y-$ axis, respectively.
o `plt.title()` displays a title above the plot
o `plt.legend()` displays the legend given inside the `plt.plot` command
o `plt.grid()` adds grid lines which makes it easier to read the plot

By visiting the official documentation, and view the "Matplotlib gallery":"https://matplotlib.org/stable/gallery/index.html", you will find examples for inspiration on how to visualize your data.
!split

<% ex_id = 0 %>
<% ex_id += 1 %>
======= Exercise ${ex_id}: Reproduce a plot  =======

* Reproduce figure ref{fig:imp:ex1} as closely as possible

FIGURE: [fig-import/ex1.png, width=400 frac=1.0] A plot of a linear function. label{fig:imp:ex1}

!split
===== Solution: =====

!bc pypro
import matplotlib.pyplot as plt
x=[1,2,3,4]
y=[1,2,3,4]
plt.title('A linear function')
plt.plot(x,y,'-o',label='y=x')
plt.xlabel('x-values')
plt.ylabel('y-values')
plt.grid() #minor grid lines for readability
plt.legend()
!ec

!split
======= Data structures  (Basic) =======
idx{data structures}
The data we want to e.g. visualize has to be stored or passed around in the code somehow. Data structures provide an interface to your data, that makes it efficient to access them. In the next subsections we give a short overview of the most used data structures, which you should be familiar with.
!split
===== Lists =====
idx{lists} idx{list comprehension}
Lists are defined using the square bracket `[]` symbol, e.g.
!bc pycod
my_list = []      # an empty list
my_list = []*10   # still an empty list ...
my_list = [0]*10  # a list with 10 zeros
my_list = ['one', 'two','three'] # a list of strings
my_list = ['one']*10 # a list with 10 equal string elements 
!ec
!bnotice
To get the first element in a list, we do e.g. `my_list[0]`. Notice that the counter start at 0 and not 1. In a list with 10 elements the last element would be `my_list[9]`, the length of a list can be found by using the `len()` function, i.e. `len(my_list)` would give =10. Thus, the last element can also be found by doing `my_list[len(my_list)-1]`. However, in Python you can always get the last element by doing `my_list[-1]`, the second last element would be `my_list[-2]` and so on.
!enotice

To add stuff to a list, we use the `append` function
!bc pycod
my_list = []      # an empty list
my_list.append(2) # [2]
my_list.append('dog') # [2, 'dog']
!ec
You can also remove stuff, using the `pop` function, then you also have to give the index
!bc pycod
my_list.pop(0) # my_list=['dog']
!ec
!bnotice print statement
As default python will usually write to screen your last statement. But at any time you can use the `print` statement to force python to print out any variable, e.g.
!bc pycod
my_list=['dog','cat',2]
print(my_list[0]) # first element
print(my_list[0],my_list[1]) # first and second element
print(my_list) # the whole list 
!ec
!enotice

!split
=== List comprehension ===

Sometimes you do not want to initialize the list with everything equal, and it can be tiresome to write everything out yourself. If that is the case you can use *list comprehension*
!bc pycod
x = [i for i in range(10)] # a list from 0,1,2,..,9
y = [i**2 for i in range(10)] # a list with elements 0,1,4, ..,81
!ec
We will cover for loops later, but basically what is done is that the statement `i in range(10)`, gives `i` the value 0, 1, $\ldots$, 9 and the first `i` inside the list tells python to use that value as the element in the list. Using this syntax, there are plenty of opportunities to initialize.


=== List arithmetic ===
I showed you some examples above, where we used multiplication to create a list with equal copies of a single element, you can also join two lists by using addition
!bc pypro
my_list  = ['hammer','saw']
my_list2 = ['screw','nail','glue']
new_list = my_list + my_list2
!ec
Now `new_list=['hammer', 'saw', 'screw', 'nail', 'glue']`, we can also multiply the list with an integer and get a larger list with several copies of the original list.

=== List slicing ===
Clearly we can access elements in a list by using the index to the element, i.e. first element is `my_list[0]`, and the last element is `my_list[-1]`. Python also has very nice syntax to pick out a subset of a list. The syntax is `my_list[start:stop:step]`, the step makes it possible to skip elements
!bc pypro
my_list=['hammer', 'saw', 'screw', 'nail', 'glue']
my_list[:]      # ['hammer', 'saw', 'screw', 'nail', 'glue']
my_list[1:]     # ['saw', 'screw', 'nail', 'glue']
my_list[:-1]    # ['hammer', 'saw', 'screw', 'nail']
my_list[1:-1]   # ['saw', 'screw', 'nail']
my_list[1:-1:2] # ['saw','nail']
my_list[::1]    # ['hammer', 'saw', 'screw', 'nail', 'glue']
my_list[::2]    # ['hammer', 'screw', 'glue']
!ec

Sometimes you have lists of lists, if you want to get e.g. the first element of each list you cannot access those elements using list slicing, you have to use a for loop or list comprehension
!bc pypro
my_list  = ['hammer','saw']
my_list2 = ['screw','nail','glue']
new_list=[my_list,my_list2]
# extract the first element of each list
new_list2 = [ list[0] for list in new_list]
!ec
`new_list2=['hammer','screw']`

!bnotice When to use lists
Use lists if you have mixed types, and as storage containers. Be careful when you do numerical computation not to mix lists and Numpy arrays. Adding two lists e.g. `[1,2]+[1,1]`, will give you `[1,2,1,1]`, whereas adding two Numpy arrays will give you `[2,3]`.
!enotice


!split
<% ex_id += 1 %>
======= Exercise ${ex_id}: Make a plot of $y=x^3$  =======

* Use $x\in[-3,3]$ and make a plot of $y=x^3$, similar to the one in figure ref{fig:imp:ex2}

FIGURE: [fig-import/ex2.png, width=400 frac=1.0] A plot of a non linear function. label{fig:imp:ex2}

!split
===== Solution =====

!bc pycod
#first we create the x-values
N=100 # 100 points
dx=6/(N-1) #N-1 to include end-points
x=[-3+i*dx for i in range(N)] #List comprehension
y=[i**3 for i in x]
plt.title('A non linear function')
plt.plot(x,y,label='$y=x^3$') # if you want you can add legend and grid lines
plt.xlabel('x-values')
plt.ylabel('y-values')
plt.grid() #minor grid lines for readability
plt.legend()
!ec


!split
===== Dictionaries  =====
idx{dictionaries}
Dictionaries are useful if your data fits the template of key:value pairs. A very good mental image to have is an excel sheet where data are organized in columns. Each column has a header name, or a *key*. Assume we have the following table

|-----------------------------------|
| x        | y           | z        |
|----c-----------c------------c-----|
|  1.0     | 1.0         | 3.0      |
|  2.0     | 4.0         |          |
|  3.0     | 9.0         |          |
|  4.0     | 16.0        |          |
|-----------------------------------|

This could be represented as a dictionary as
!bc pycod
my_dict={'x':[1.,2.,3.,4.],'y':[1.,4.,9.,16.],'z':[3.]}
!ec
The syntax is `{key1:values, key2:values2, ...}`. We access the values in the dictionary by the key i.e. `print(my_dict['x'])` would print `[1.,2.,3.,4.]`.

If you want to print out everything in a dictionary, we need to use a for loop
!bc pycod
for key in my_dict:
    print(key) # prints 'x', 'y', 'z'
    print(my_dict[key]) # prints the lists
!ec
!split

=== Example: Add numbers to dictionary and plot ===
* Add two numbers to the list of `x` and `y` in `my_dict` and plot `y` vs `x`

=== Solution ===
!bc pycod
import matplotlib.pyplot as plt
my_dict={'x':[1.,2.,3.,4.],'y':[1.,4.,9.,16.],'z':[3.]}
# add two numbers
my_dict['x'].append(-3)
my_dict['y'].append(-10)
plt.plot(my_dict['x'],my_dict['y'])
#alternatively only points
plt.plot(my_dict['x'],my_dict['y'],'*')
!ec

!split
===== Tuples =====
idx{tuples}
A tuple is a data structure that in many respects is equal to a list. It can contain various Python objects, *but the elements cannot be changed after the tuple has been created*. It is created by using round parenthesis, `()` as opposed to the square parenthesis, `[]`, used in list creation.
!bc pycod
my_tuple=(1,2,3,4)
print(my_tuple[0]) # would give 1
print(my_tuple[-1]) # would give 4
my_tuple[0]=2 # would give an error message
!ec

!bnotice Tuples vs Lists
The obvious difference between tuples and lists is that you cannot change tuples after they have been created, in Python an object where you cannot change the state after it has been created is called *immutable* as opposed to *mutable*. Since tuples are immutable, you can also use them as keys in dictionaries. This can be useful if you need a lookup value that contains more information, e.g.
!bc pycod
my_dict={}
my_dict[('perm','mD')]=[50,100,250]
!ec
!enotice

!split
======= Numpy: Working with numerical arrays in Python =======
idx{numpy}
In the above example we used lists to store values that we wanted to plot. Lists are one of the basic data structures in Python, but since they are so flexible they are not well suited for mathematical operations. If you are only working with arrays that contain numbers you should use the "Numpy":"https://numpy.org/" library. The above example in Numpy would be
!bc pycod
import numpy as np
x=np.linspace(-3,3,100) # vector of 100 points from -3 to 3
y=x*x # multiply each number in x by itself
plt.plot(x,y)
!ec
Numpy has built in functions that allows you to calculate e.g. the logarithm, sine, exponential of arrays
!bc
np.log(x) # log of all elements in x
np.exp(x) # exp of all elements in x
np.sin(x) # sin of all elements in x
!ec
If you have a list, it can easily be converted to a Numpy array
!bc pycod
x=[1,4,7] # x is a list
x+x # x+x would give [1,4,7,1,4,7]
x*x # would give an error message
!ec
!bc pycod
x=np.array([1,4,7]) # now x is a Numpy array
x+x # would give [2,8,14]
x*x # would give [1,16,49]
x/x # would give [1.,1.,1.]
!ec
!split
======= Boolean masking =======
idx{boolean masking}
A variable that only take the value `True` or `False` is called Boolean. A Boolean type takes up the smallest amount of memory (one byte). It is a subclass of integer, `int`, and if you add or subtract them, `True` and `False` will be given the value of 1 and 0 respectively.  In many applications you would like to pick out only a part of the elements in an array. If we work with Numpy arrays, it is extremely easy achieve this using Boolean masking or Boolean indexing. The word ''mask'' is used to indicate which bits we want to keep, and which we want to remove. It is best demonstrated on some examples (NB: following syntax will not work on lists)
!bc pycod
x=np.array([4,5,7,8,9]) #create numpy array from a list
print(x>5) # [False, False, True, True, True]
print(np.sum(x>5)) # 0+0+1+1+1=3
print(x[x>5]) # [7,8,9]
print(np.sum(x[x>5])) 24
!ec

!split
<% ex_id += 1 %>
======= Exercise ${ex_id}: Make a plot of $y=x^3$ using Numpy =======

* Use $x\in[-3,3]$ and make a plot of $y=x^3$, similar to the one in figure ref{fig:imp:ex2} as you did before, but this time use Numpy.

!split
===== Solution =====

!bc pycod
import numpy as np
N=100
x=np.linspace(-3,3,N)
y=x**3 #element wise operation 
#Done, rest is just to make the plot
plt.title('A non linear function')
plt.plot(x,y,label='$y=x^3$') # if you want you can add legend and grid lines
plt.xlabel('x-values')
plt.ylabel('y-values')
plt.grid()
plt.legend()
!ec

!split

======= Pathlib: Working with files and folders in Python =======
idx{pathlib}
When you want to open a file in a Python script, you first have to locate it. If you have downloaded all the files, there will be a `data` folder in which there are several data sets. Sometimes we would like to list all files in a folder, or files of a certain type, and/or create a unique file name that does not already exists. 
##, we look at some well data from "GeoProvider":"http://geoprovider.no/". 

To access files one can use strings, but in practice this can be very tiresome, especially as a path in Windows has a different syntax than e.g. Linux. In Windows directories and sub directories are indicated with a backslash, `\`, whereas in Linux it is a forward slash `/`.

It is much better to use the Pathlib library and work with *Path objects*, then your code would work regardless of operating system.

!split
===== Pathlib cwd(): Current working directory =====

How can you know which directory your are currently in? Using Pathlib we can do
!bc pycod
import pathlib as pt
p=pt.Path('.') # we create a Path object
print(p.cwd()) # cwd = current working directory
!ec
What happens here?
o `import pathlib as pt` imports Pathlib which we name `pt`. Functions in Pathlib is accessed with the `.` syntax.
o We create a Path object, by `p=pt.Path('.')` and store it in the variable `p`. The `'.'` argument is the current directory.
o Now we have access to build-in functions int the Path object by using the `.` syntax, and we can print current working directory `print(p.cwd())`

!split
===== List all files and folder in current directory =====
As mentioned before, a for-loop is a way to tell the computer to do something until a certain condition has been met. The code for listing all files and directories in a folder is 
!bc pycod
import pathlib as pt
p=pt.Path('.') # the directory where this python file is located
for x in p.iterdir():
    if x.is_dir():#NB Indentation, all below belongs to p.iterdir()
        print('Found dir: ', x) #NB Indentation, belongs to if x.is_dir()
    elif x.is_file():
        print('Found file: ', x) #NB Indentation, belongs to if x.is_file()
!ec
`p.iterdir()` is a *generator*, and you can simply think of it as generating a list of all files and folders in the `'.'` (current) directory. To view the elements in `p.iterdir()`, you can do
!bc pycod
print(list(p.iterdir()))
!ec
Let us go through each line
o `p=pt.Path('.')` we create a Path object and name it `p`.
o The next part is the for-loop, the variable `x` takes on the value of each element in the list generated by `p.iter_dir()`.
o `x.is_dir()`, gives True if `x` is a directory and False if not.
o `x.is_file()`, gives True if `x` is a file and False if not.

!split
__List all files of a type:__
Below we use `p.rglob()`, and not `p.iterdir()`, the difference is that `rglob()` also lists recursively the sub directories, and files within.
!bc pycod
p=pt.Path('.')
for x in p.rglob("*.xlsx"):# rglob means recursively, searches sub directories
    print(x.name)
!ec
If you want to print the full path do `print(x.absolute())`.

!split
__Create a directory, files and joining paths:__
!bc pycod
pt.Path('tmp_dir').mkdir()
!ec
If you run the code twice it will produce an error, because the directory exists, then we can simply do `Path('tmp_dir').mkdir(exist_ok=True)`.


Furthermore, the forward slash, `/`, can be used combine paths
!bc pycod
p=pt.Path('.')
new_path = p / 'tmp_dir' / 'my_file.txt'
print(new_path.absolute())
print(p.exists()) # gives False, because my_file.txt does not exists
new_path.touch() # touch creates file, tmp_dir must exists
print(p.exists()) # gives True 
!ec

!split
======= Pandas: Working with tabulated data (Excel files) =======
idx{pandas}
Pandas is a Python package that among many things are used to handle data, and perform operations on groups of data. It is built on top of Numpy, which makes it easy to perform vectorized operations. Pandas is written by Wes McKinney, and one of it objectives is according to the official website " '' providing fast, flexible, and expressive data structures designed to make working with ''relational'' or ''labeled'' data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, real-world data analysis in Python''":"https://pandas.pydata.org/". Pandas also has excellent functions for reading and writing excel and csv files.  An excel file is read directly into memory in what is called a `DataFrame` in Pandas. A DataFrame is a two dimensional object where data are typically stored in column or row format.

!bnotice Pandas has a lot of functionality
Pandas has so much functionality that it is almost like a programming language. Here we will only use it to read and write excel files, and do some basic filtering of data. However, there is a high probability that whatever you would like to do with your data, e.g. clean, filter, mathematical operations, there is already a Pandas command to achieve your goal.
!enotice
!split
===== DataFrame: The basic object in Pandas =====
idx{DataFrame}
!bnotice What is a DataFrame?
You should think of a DataFrame as a single sheet in Excel with tabulated data. A DataFrame will typically have data stored with a header name and data in an array associated with that header, as illustrated in ref{fig:file}.  
!enotice

FIGURE: [fig-import/covid_comb.png, width=400 frac=1.0] Official Covid-19 data, and example of files (left) tab separated (right) excel file. label{fig:file}

If we have file in the `data` directory, we can import them into a DataFrame as follows

!bc pycod
import pandas as pd
df=pd.read_excel('../data/corona_data.xlsx') # excel file
df2=pd.read_csv('../data/corona_data.dat',sep='\t') # csv tab separated file
!ec
If the excel file has several sheets, you can give the sheet name directly, e.g. `df=pd.read_excel('file.xlsx',sheet_name="Sheet1")`, for more information see the "documentation":"https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html". 

We can easily save the data frame to excel format and open it in excel
!bc pycod
df.to_excel('covid19.xlsx', index=False) # what happens if you put index=True?
!ec

!bnotice Index column
Whenever you create a DataFrame Pandas by default create an index column, it contains an integer for each row starting at zero. It can be accessed by `df.index`, and it is also possible to define another column as index column. 
!enotice
!split
===== Create DataFrame from dictionary =====
A DataFrame can be quite easily be generated from a dictionary. A dictionary is a special data structure, where an unique key is associated with a data type (key:value pair). In this case, the key would be the title of the column, and the value would be the data in the columns.
##To generate the excel file in figure ref{fig:file}, we can do (see figure ref{fig:pandas:cc} for the final result)
!bc pycod
my_dict={'ints':[0,1,2,3], 'floats':[4.,5.,6.,7.],
'tools':['hammer','saw','rock','nail']
}
my_df=pd.DataFrame(my_dict)
print(my_df) # to view
!ec

!split
===== Accessing data in  DataFrames =====

===  Selecting columns  ===

If we want to pick out a specific column we can access it in the following ways
!bc pycod
# following two are equivalent
df=pd.read_excel('../data/corona_data.xlsx')
time=df['TIME'] # by the name, alternatively
time=df[df.columns[1]]
# following two are equivalent
time=df.loc[:,['TIME']] # by loc[] if we use name
time=df.iloc[:,1] # by iloc, pick column number 1
!ec
The `loc[]` and `iloc[]` functions also allows for list slicing, one can then pick e.g. every second element in the column by `time=df.iloc[::2,1]` etc. The difference is that `loc[]` uses the name, and `iloc[]` the index (usually an integer). 

Why several ways of doing the same operation? It turns out that although we are able to extract what we want with these operations, they are of different type
!bc pycod
print(type(df['TIME']))
print(type(df.loc[:,['TIME']]))
!ec
===  Selecting rows  ===
When selecting rows in a DataFrame, we can use the `loc[]` and `iloc[]` functions
!bc pycod
# pick column number 0 and 1
time=df.loc[0:1,:] # by loc[] 
time=df.iloc[0:2,:] # by iloc
!ec

!bnotice `pandas.DataFrame.loc` vs `pandas.DataFrame.iloc`
When selecting rows `loc` and `iloc` they behave differently, `loc` includes the endpoints (in the example above both row 0 and 1), whereas `iloc` includes the starting point and up to 1 minus the endpoint. 
!enotice

=== Challenges when accessing columns or rows ===

!bnotice Special characters 
Sometimes when reading files from excel, headers may contains invisible characters like newline `\n` or tab `\t` or maybe Norwegian special letters that have not been read in properly. If you have problem accessing a column by name do `print(df.columns)` and check if the name matches what you would expect.  
!enotice

If the header names has unwanted white space, one can do
!bc pycod
df.columns = df.columns.str.replace(' ', '') # all white spaces
df.columns = df.columns.str.lstrip() # the beginning of string
df.columns = df.columns.str.rstrip() # end of string
df.columns = df.columns.str.strip()  # both ends
!ec
Similarly for unwanted tabs
!bc pycod
df.columns = df.columns.str.replace('\t', '') # remove tab
!ec
If you want to make sure that the columns does not contain any white spaces, one can use "`pandas.Series.str.strip()`":"https://pandas.pydata.org/pandas-docs/version/1.2.4/reference/api/pandas.Series.str.strip.html"
!bc pycod
df['LOCATION']=df['LOCATION'].str.strip()
!ec

!split
===== Datetime: Time columns not parsed properly  =====

If you have dates in the file (as in our case for the `TIME` column), you should check if they are in the `datetime` format and not read as `str`.

!bnotice `datetime`
The `datetime` library is very useful for working with dates. Data types of the type `datetime` (or equivalently `timestamp` used by Pandas) contains both date and time in the format `YYYY-MM-DD hh:mm:ss`. We can initialize a variable, `a`, by `a=datetime.datetime(2022,8,30,10,14,1)`, to access the hour we do `a.hour`, the year by `a.year` etc. It also easy to increase e.g. the day by one by doing `a+datetime.timedelta(days=1)`. 
!enotice

!bc pycod
import datetime as dt
df=pd.read_excel('../data/corona_data.xlsx')
time=df['TIME']
# what happens if you set
# df2=pd.read_csv('../data/corona_data.dat',sep='\t') # csv tab separated file
# time=df2['TIME'] #i.e df2 is from pd.read_csv ?
print(time[0])
print(time[0]+dt.timedelta(days=1))
!ec

The code above might work fine or in some cases a date is parsed as a string by Pandas, then we need to convert that column to the correct format. If not, we get into problems if you want to plot data vs the time column.

Below are two ways of converting the `TIME` column
!bc pycod
df2['TIME']=pd.to_datetime(df2['TIME'])
# just for testing that everything went ok
time=df2['TIME']
print(time[0])
print(time[0]+dt.timedelta(days=1))
!ec

Another possibility is to do the conversion when reading the data:
!bc pycod
df2=pd.read_csv('../data/corona_data.dat',sep='\t',parse_dates=['TIME']) 
!ec
If you have a need to specify all data types, to avoid potential problems down the line this can also be done. First create a dictionary, with column names and data types
!bc pycod
types_dict={"LOCATION":str,"TIME":str,"ELAPSED_TIME_SINCE_OUTBREAK":int,"CONFIRMED":int,"DEATHS":int,"RECOVERED":int}
df2=pd.read_csv('../data/corona_data.dat',sep='\t',dtype=types_dict,parse_dates=['TIME']) # set data types explicit
!ec
Note that the time data type is `str`, but we explicitly tell Pandas to convert those to `datetime`.

!split
===== Pandas: Filtering and visualizing data =====
=== Boolean masking ===
Typically you would select rows based on a criterion, the syntax in Pandas is that you enter a series containing `True` and `False` for the rows you want to pick out, e.g. to pick out all entries with Afghanistan we can do
!bc pycod
df[df['LOCATION'] == 'Afghanistan']
!ec
The innermost statement `df['LOCATION'] == 'Afghanistan'` gives a logical vector with the value `True` for the five last elements and `False` for the rest. Then we pass this to the DataFrame, and in one go the unwanted elements are removed. It is also possible to use several criteria, e.g. only extracting data after a specific time
!bc pycod
df[(df['LOCATION'] == 'Afghanistan') & (df['ELAPSED_TIME_SINCE_OUTBREAK'] > 2)]
!ec
Note that the parenthesis are necessary, otherwise the logical operation would fail.

=== Plotting a DataFrame ===
Pandas has built in plotting, by calling "`pandas.DataFrame.plot`":"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html".
!bc pycod
df2=df[(df['LOCATION'] == 'Afghanistan')]
df2.plot()
#try 
#df2=df2.set_index('TIME')
#df2.plot() # what is the difference?
#df2.plot(y=['CONFIRMED','DEATHS'])
!ec

===== Performing mathematical operations on DataFrames =====
When performing mathematical operations on DataFrames there are at least two strategies
* Extract columns from the DataFrame and perform mathematical operations on the columns using Numpy, leaving the original DataFrame intact
* To operate directly on the data in the DataFrame using the Pandas library

!bnotice Speed and performance
Using Pandas or Numpy should in principle be equally fast. The advice is to not worry about performance before it is necessary. Use the methods you are confident with, and try to be consistent. By consistent, we mean that if you have found one way of doing a certain operation stick to that one and try not to implement many different ways of doing the same thing. 
!enotice

We can always access the individual columns in a DataFrame by the syntax `df['column_name']`. 
=== Example: mathematical operations on DataFrames ===
o Create a DataFrame with one column (`a`) containing ten thousand random uniformly distributed numbers between 0 and 1 (checkout "`np.random.uniform`":"https://numpy.org/doc/stable/reference/random/generated/numpy.random.uniform.html")
o Add two new columns: one which all elements of `a` is squared and one where the sine function is applied to column `a`
o Calculate the inverse of all the numbers in the DataFrame
o Make a plot of the results (i.e. `a` vs `a*a`, and `a` vs `sin(a)`)

=== Solution ===
o First we make the DataFrame
!bc pycod
import numpy as np
import pandas as pd
N=10000
a=np.random.uniform(0,1,size=N)
df=pd.DataFrame() # empty DataFrame
df['a']=a
!ec
If you like you could also try to use a dictionary. Next, we add the new columns
!bc pycod
df['b']=df['a']*df['a'] # alternatively np.square(df['a'])
df['c']=np.sin(df['a'])
!ec

o The inverse of all the numbers in the DataFrame can be calculated by simply doing
!bc pycod
1/df
!ec
Note: you can also do `df+df` and many other operations on the whole DataFrame.

o To make plots there are several possibilities. Personally, I tend most of the time to use the  "`matplotlib`":"https://matplotlib.org/" library, simply because I know it quite well, but Pandas has a great deal of very simple methods you can use to generate nice plots with very few commands.

__Matplotlib:__
!bc pycod
import matplotlib.pyplot as plt
plt.plot(df['a'],df['b'], '*', label='$a^2$')
plt.plot(df['a'],df['c'], '^', label='$\sin(a)$')
plt.legend() 
plt.grid() # make small grid lines
plt.show()
!ec

__Pandas plotting:__
First, let us try the built in plot command in Pandas
!bc pycod
df.plot()
!ec
If you compare this plot with the previous plot, you will see that Pandas plots all columns versus the index columns, which is not what we want. But, we can set `a` to be the index column
!bc pycod
df=df.set_index('a')
df.plot()
!ec
We can also make separate plots
!bc pycod
df.plot(subplots=True)
!ec
or scatter plots
!bc pycod
df=df.reset_index()
df.plot.scatter(x='a',y='b')
df.plot.scatter(x='a',y='c')
!ec
Note that we have to reset the index, otherwise there are no column named `a`. 

!split
===== Grouping, filtering and aggregating data =====
Whenever you have a data set, you would like to do some exploratory analysis. That typically means that you would like to group, filter or aggregate data. Perhaps, we would like to plot the covid data not per country, but the data as a function of dates. Then you first must sort the data according to date, and then sum all the occurrences on that particular date. For all of these purposes we can use the "`pd.DataFrame.groupby()`":"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html " function. To sort our DataFrame on dates and sum the occurrences we can do
!bc pycod
df.groupby('TIME').sum()
!ec

Another case could be that we wanted to find the total number of confirmed, deaths and recovered cases in the full database. As always in Python it can be done in different ways, by e.g. splitting the database into individual countries and do  `df[['CONFIRMED','DEATHS','RECOVERED']].sum()` or accessing each column individually and sum each of them e.g. `np.sum(df['CONFIRMED'])`.  However, with the `groupby()` function
# #if FORMAT in ("html","pdflatex", "latex")
(see figure ref{fig:pandas:group} for final result)
# #endif
!bc pycod
df.groupby('LOCATION').sum()
!ec
Here Pandas sum all columns with the same location, and drop columns that cannot be summed. By doing `df.groupby('LOCATION').mean()` or `df.groupby('LOCATION').std()` we can find the mean or standard deviation (per day).

# #if FORMAT not in ("ipynb")
FIGURE: [fig-import/group.png, width=400 frac=1.0] The results of `df.groupby('LOCATION').sum()`. label{fig:pandas:group}
# #endif


===== Simple statistics in Pandas =====
At the end it is worth mentioning the built in methods `pd.DataFrame.mean`, `pd.DataFrame.median`, `pd.DataFrame.std` which calculates the mean, median and standard deviation on the columns in the DataFrame where it make sense (i.e. avoid strings and dates). To get all these values in one go (and a few more) on can also use `pd.DataFrame.describe()`
!bc pypro
df.describe()
!ec
# #if FORMAT not in ("ipynb")
The output is shown in figure ref{fig:pandas:desc}
FIGURE: [fig-import/describe.png, width=400 frac=1.0] Output from the describe command. label{fig:pandas:desc}
# #endif


===== Joining two DataFrames =====
=== Appending DataFrames  ===
The DataFrame with the Covid-19 data in the previous section could have been created from two separate DataFrames, using "`concat()`":"https://pandas.pydata.org/docs/reference/api/pandas.concat.html". First, create two DataFrames 
!bc pypro
import datetime as dt
a=dt.datetime(2020,2,24,23,59)
b=dt.datetime(2020,2,7,23,59)
my_dict1={'LOCATION':7*['Afghanistan'], 
'TIME':[a+dt.timedelta(days=i) for i in range(7)],
'ELAPSED_TIME_SINCE_OUTBREAK':[0, 1, 2, 3, 4, 5, 6],
'CONFIRMED':7*[1],
'DEATHS':7*[0],
'RECOVERED': 7*[0]}
my_dict2={'LOCATION':6*['Diamond Princess'], 
'TIME':[b+dt.timedelta(days=i) for i in range(6)],
'ELAPSED_TIME_SINCE_OUTBREAK':[0, 1, 2, 3, 4, 5],
'CONFIRMED':[61, 61, 64, 135, 135, 175],
'DEATHS':6*[0],
'RECOVERED': 6*[0]}
df1=pd.DataFrame(my_dict1)
df2=pd.DataFrame(my_dict2)
!ec
# #if FORMAT not in ("ipynb")
Next, add them row wise (see figure ref{fig:pandas:concat})
# #endif

!bc pypro
df=pd.concat([df1,df2])
print(df) # to view
!ec

# #if FORMAT not in ("ipynb")
FIGURE: [fig-import/concat.png, width=400 frac=1.0] The result of `concat()`. label{fig:pandas:concat}
# #endif

If you compare this DataFrame with the previous one, you will see that the index column is different. This is because when joining two DataFrames Pandas does not reset the index by default, doing `df=pd.concat([df1,df2],ignore_index=True)` resets the index. It is also possible to join DataFrames column vise
!bc pypro
pd.concat([df1,df2],axis=1)
!ec

=== Merging DataFrames ===

In the previous example we had two non overlapping DataFrames (separate countries and times). It could also be the case that some of the data was overlapping e.g. continuing with the Covid-19 data, one could assume that there was one data set from one region and one from another region in the same country
!bc pypro
my_dict1={'LOCATION':7*['Diamond Princess'], 
'TIME':[b+dt.timedelta(days=i) for i in range(7)],
'ELAPSED_TIME_SINCE_OUTBREAK':[0, 1, 2, 3, 4, 5, 6],
'CONFIRMED':7*[1],
'DEATHS':7*[0],
'RECOVERED': 7*[0]}
my_dict2={'LOCATION':2*['Diamond Princess'], 
'TIME':[b+dt.timedelta(days=i) for i in range(2)],
'ELAPSED_TIME_SINCE_OUTBREAK':[0, 1],
'CONFIRMED':[60, 60],
'DEATHS':2*[0],
'RECOVERED': 2*[0]}
df1=pd.DataFrame(my_dict1)
df2=pd.DataFrame(my_dict2)
!ec
If we do `pd.concat([df1,df2])` we will simply add all values after each other. What we want to do is to sum the number of confirmed, recovered and deaths for the same date. This can be done in several ways, but one way is to use "`pd.DataFrame.merge()`":"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html".You can specify the columns to merge on, and choose `outer` which is union (all data from both frames) or `inner` which means the intersect (only data which you merge on that exists in both frames), see figure ref{fig:pandas:join} for a visual image.

FIGURE: [fig-import/fig_join.png, width=400 frac=1.0] The result of using `how=outer, inner, left`, or `right` in `pd.DataFrame.merge()`. label{fig:pandas:join}

To be even more specific, after performing the commands
!bc pypro
df1.merge(df2,on=['LOCATION','TIME'],how='outer')
df1.merge(df2,on=['LOCATION','TIME'],how='inner')
!ec

# #if FORMAT not in ("ipynb")
we get the results in figure ref{fig:pd:merge} 

FIGURE: [fig-import/merge.png, width=400 frac=1.0] Merging to DataFrame using `outer` (top) and `inner` (bottom). label{fig:pd:merge}

# #endif
Clearly in this case we need to choose `outer`. In the merge process pandas adds an extra subscript `_x` and `_y` on columns that contains the same header name. We also need to sum those, which can be done as follows
# #if FORMAT not in ("ipynb")
(see figure ref{fig:pandas:merge3} for the final result)
# #endif

!bc pypro
df=df1.merge(df2,on=['LOCATION','TIME'],how='outer')
cols=['CONFIRMED','DEATHS', 'RECOVERED']
for col in cols:
    df[col]=df[[col+'_x',col+'_y']].sum(axis=1) # sum row elements
    df=df.drop(columns=[col+'_x',col+'_y']) # remove obsolete columns
# final clean up
df['ELAPSED_TIME_SINCE_OUTBREAK']=df['ELAPSED_TIME_SINCE_OUTBREAK_x']		
df=df.drop(columns=['ELAPSED_TIME_SINCE_OUTBREAK_y','ELAPSED_TIME_SINCE_OUTBREAK_x'])
!ec

# #if FORMAT not in ("ipynb")
FIGURE: [fig-import/merge3.png, width=400 frac=1.0] Result of outer merging and summing. label{fig:pandas:merge3}
# #endif

